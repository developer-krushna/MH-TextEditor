{
  "name": ["Python", ".py"],
  "comment": [
    { "startsWith": "#" }
  ],
  
  "rules": [
    // Single-line comments
    { "type": "comment", "regex": "#.*" },
    
    // Multi-line comments (triple double quotes at start of line)
    {
      "regex": "(?m)^\\s*\"\"\"[\\s\\S]*?\"\"\"",
      "groupStyles": { "0": "comment" }
    },
    
    // Multi-line comments (triple single quotes at start of line)
    {
      "regex": "(?m)^\\s*'''[\\s\\S]*?'''",
      "groupStyles": { "0": "comment" }
    },
    
    // Triple double quoted strings
    {
      "regex": "\"\"\"[\\s\\S]*?\"\"\"",
      "groupStyles": { "0": "string" }
    },
    
    // Triple single quoted strings
    {
      "regex": "'''[\\s\\S]*?'''",
      "groupStyles": { "0": "string" }
    },
    
    // Double quoted strings
    {
      "regex": "\"(?:\\\\.|[^\"])*\"",
      "groupStyles": { "0": "string" }
    },
    
    // Single quoted strings
    {
      "regex": "'(?:\\\\.|[^'])*'",
      "groupStyles": { "0": "string" }
    },
    
    // String escape sequences
    { "type": "strEscape", "regex": "\\\\u[0-9a-fA-F]{4}|\\\\x[0-9a-fA-F]{2}|\\\\[0-7]{1,3}|\\\\." },
    
    // Numbers - binary
    { "type": "number", "regex": "\\b0[bB][01_]+\\b" },
    
    // Numbers - octal
    { "type": "number", "regex": "\\b0[oO][0-7_]+\\b" },
    
    // Numbers - hex
    { "type": "number", "regex": "\\b0[xX][0-9a-fA-F_]+\\b" },
    
    // Numbers - decimal with scientific notation and complex
    { "type": "number", "regex": "\\b\\d[\\d_]*(?:\\.\\d[\\d_]*)?(?:[eE][+-]?\\d[\\d_]*)?[jJ]?\\b" },
    { "type": "number", "regex": "\\b\\d[\\d_]*[jJ]\\b" },
    
    // Built-in types - only match when they are standalone words
    {
      "type": "type",
      "regex": "\\b(?:int|float|long|complex|str|unicode|list|tuple|bytearray|buffer|xrange|set|frozenset|dict|bool)\\b"
    },
    
    // Keywords - only match when they are standalone words
    {
      "type": "keyword",
      "regex": "\\b(?:True|False|None|self|NotImplemented|Ellipsis|__debug__|__file__|and|del|from|not|while|as|elif|global|or|with|assert|else|if|pass|yield|break|except|import|print|class|exec|in|raise|continue|finally|is|return|def|for|lambda|try)\\b"
    },
    
    // Exception and error types - only match when they are standalone words
    {
      "type": "keyword2", 
      "regex": "\\b(?:ArithmeticError|AssertionError|AttributeError|BaseException|DeprecationWarning|EnvironmentError|EOFError|Exception|FloatingPointError|FutureWarning|GeneratorExit|IOError|ImportError|ImportWarning|IndexError|KeyError|KeyboardInterrupt|LookupError|MemoryError|NameError|NotImplementedError|OSError|OverflowError|PendingDeprecationWarning|ReferenceError|RuntimeError|RuntimeWarning|StandardError|StopIteration|SyntaxError|SyntaxWarning|SystemError|SystemExit|TypeError|UnboundLocalError|UserWarning|UnicodeError|UnicodeWarning|UnicodeEncodeError|UnicodeDecodeError|UnicodeTranslateError|ValueError|Warning|WindowsError|ZeroDivisionError)\\b"
    },
    
    // Operators
    { "type": "operator", "regex": "[+\\-*/%=&|!<>^~]+|\\.|,|;|:|@|\\(|\\)|\\{|\\}|\\[|\\]" },
    
    // Default fallback - should be last
    { "type": "default", "regex": "." }
  ]
}